# Project Tech Stack

- **Backend**: Java 17, Spring Boot 3.2, Maven
- **Frontend**: Next.js 14, React 18, TypeScript, Tailwind CSS, Shadcn
- **Database**: PostgreSQL
- **Testing**: JUnit, Testcontainers (Backend); Jest, React Testing Library (Frontend)
- **DevOps**: Docker, Docker Compose, Kubernetes, Terraform, Terragrunt

# Development Workflow and Process

This section outlines the recommended end-to-end process for developing a modern, cloud-native, containerized full-stack application from initial concept through production deployment.

**Note:** This guide uses Google Cloud Platform (GCP) services (GKE, GCR, GCS, Cloud SQL, Secret Manager), but the same principles apply to other cloud providers:
- **AWS**: EKS, ECR, S3, RDS, Secrets Manager
- **Azure**: AKS, ACR, Blob Storage, Azure SQL, Key Vault
- **On-Premise**: Self-managed Kubernetes, Harbor/Nexus, MinIO, PostgreSQL, Vault

## Guiding Principles

- **Test Early, Test Often**: Write tests alongside feature development (TDD approach)
- **CI from Day One**: Initialize CI on first commit and evolve it with the project
- **Infrastructure as Code**: All infrastructure defined in version-controlled code
- **Security by Design**: Never commit secrets, use environment variables and secret managers
- **Dev-Prod Parity**: Development environment mirrors production as closely as possible

## Step-by-Step Development Process

### 1. Project Setup & MVP Foundation

**Objective**: Establish project structure and foundational setup

**Actions**:
- Initialize Git repository from the start
- Set up project structure:
  - `backend/` - Spring Boot application
  - `frontend/` - Next.js application
  - `.github/workflows/` - CI/CD pipelines (even if minimal)
  - `k8s/` - Kubernetes manifests (create stubs)
  - `terraform/` - Infrastructure code (create stubs)
- Create `.gitignore` ensuring `.env` files are excluded
- Create `.env.example` with all required variables (no actual secrets)
- Set up linting and code formatting (Prettier, ESLint, Checkstyle)
- **Initialize basic CI workflow immediately** - even if it just runs linting

**Deliverables**:
- âœ… Git repository initialized with proper `.gitignore`
- âœ… Project directory structure created
- âœ… Basic CI workflow (`.github/workflows/ci.yml`) that runs on every commit
- âœ… README.md with setup instructions
- âœ… `.env.example` file committed

### 2. Containerization with Docker

**Objective**: Create Docker configurations for development and production

**Why Early?** Containerization ensures your development environment matches production from day one, preventing "works on my machine" issues.

**Actions**:
- Create `Dockerfile` for production builds (multi-stage for backend)
  - Backend: Use `maven:3.9-eclipse-temurin-17` for build, `eclipse-temurin:17-jre` for runtime
  - Frontend: Use `node:20-alpine`, build with `npm run build`, use Next.js standalone output
- Create `Dockerfile.dev` for development with hot-reload
  - Backend: Use Maven image, mount source as volumes, enable Spring DevTools
  - Frontend: Use Node image, mount source as volumes, run `npm run dev` with file watching
- Create `docker-compose.yml` for production-like local testing
- Create `docker-compose.dev.yml` for local development with hot-reload
- Create `.dockerignore` files to exclude unnecessary files from Docker context
- **Update CI workflow** to build Docker images and verify they work

**Deliverables**:
- âœ… `Dockerfile` and `Dockerfile.dev` for both backend and frontend
- âœ… `docker-compose.yml` and `docker-compose.dev.yml`
- âœ… `.dockerignore` files
- âœ… CI builds and tests Docker images
- âœ… Local development using `docker-compose -f docker-compose.dev.yml up`

### 3. Testing Strategy (Integrated Throughout Development)

**Objective**: Establish comprehensive testing approach

**Why Integrated?** Testing should be part of feature development, not an afterthought. Write tests as you build features.

**Actions**:
- **Backend Testing**:
  - Set up JUnit 5 and Mockito for unit tests
  - Configure Testcontainers for integration tests with real PostgreSQL
  - Use `@DataJpaTest` for repository tests
  - Use `@SpringBootTest` for full integration tests
  - Add `@WebMvcTest` for controller tests
- **Frontend Testing**:
  - Set up Jest and React Testing Library
  - Write component tests for UI components
  - Add integration tests for API interactions
  - Use Mock Service Worker (MSW) for API mocking
- **E2E Testing** (Optional, for critical flows):
  - Set up Playwright or Cypress
  - Test critical user journeys
- **Update CI** to run all tests on every commit
  - Unit tests: Fast feedback
  - Integration tests: Run with Testcontainers
  - E2E tests: Run on staging deployments

**Testing Philosophy**:
- Write tests before or alongside feature code (TDD)
- Aim for high code coverage but focus on meaningful tests
- Test behavior, not implementation details
- Keep tests fast and deterministic

**Deliverables**:
- âœ… Test frameworks configured for backend and frontend
- âœ… Tests run automatically in CI on every commit
- âœ… Test coverage reports generated
- âœ… Integration tests use Testcontainers for production parity

### 4. Continuous Integration (CI) Pipeline

**Objective**: Automated build, test, and validation on every commit

**Why Early?** CI should start simple on day one and grow with the project. It provides immediate feedback and prevents integration issues.

**Actions**:
- Expand `.github/workflows/ci.yml`:
  - Checkout code
  - Set up Java and Node.js
  - Run linters (ESLint, Checkstyle)
  - Run unit tests
  - Run integration tests
  - Build Docker images
  - Run security scans (Trivy for containers, OWASP Dependency-Check)
  - Upload test coverage reports
- Configure CI to run on:
  - Every push to any branch
  - Every pull request
  - Scheduled runs (daily/weekly for dependency checks)
- Set branch protection rules:
  - Require CI to pass before merging
  - Require code reviews
  - Prevent force pushes to `main` and `develop`

**Deliverables**:
- âœ… Comprehensive CI pipeline in `.github/workflows/ci.yml`
- âœ… CI runs on all commits and pull requests
- âœ… Branch protection rules enforced
- âœ… Security scanning integrated
- âœ… Failed tests block PR merges

### 5. Infrastructure as Code (Terraform + Terragrunt)

**Objective**: Define all cloud infrastructure in version-controlled code

**Why Before K8s?** You need infrastructure (VPC, subnets, managed K8s cluster, databases) before you can deploy Kubernetes workloads.

**Actions**:
- Set up Terraform project structure:
terraform/ 
â”œâ”€â”€ environments/ 
â”‚ â”œâ”€â”€ staging/ 
â”‚ â”‚ â”œâ”€â”€ terragrunt.hcl 
â”‚ â”‚ â””â”€â”€ terraform.tfvars 
â”‚ â””â”€â”€ production/ 
â”‚ â”œâ”€â”€ terragrunt.hcl 
â”‚ â””â”€â”€ terraform.tfvars 
â”œâ”€â”€ modules/ 
â”‚ â”œâ”€â”€ networking/ 
â”‚ â”œâ”€â”€ gke/ 
â”‚ â”œâ”€â”€ database/ 
â”‚ â””â”€â”€ storage/ 
â”œâ”€â”€ backend.tf # Remote state configuration 
â””â”€â”€ versions.tf

- **Use Terragrunt for multi-environment support**:
  - DRY principle: Write Terraform once, configure per environment with Terragrunt
  - Separate state files per environment
  - Environment-specific variables (cluster size, database tier, etc.)
- Define infrastructure resources:
  - VPC and subnets
  - GKE cluster (or EKS/AKS for AWS/Azure)
  - Cloud SQL (managed PostgreSQL)
  - GCS buckets for storage and Terraform state
  - IAM roles and service accounts
  - Secret Manager for secrets
- Configure remote state backend (GCS with locking)
- Create `.github/workflows/terraform-plan.yml` for PR validation
- Create `.github/workflows/terraform-apply.yml` for applying changes
- **Never apply Terraform manually** - always through CI/CD

**Terragrunt Benefits**:
- Keeps Terraform code DRY across environments
- Manages remote state configuration automatically
- Supports dependencies between modules
- Easier to scale to multiple projects/teams

**Deliverables**:
- âœ… Terraform modules for all infrastructure components
- âœ… Terragrunt configurations for staging and production
- âœ… Remote state backend configured (GCS)
- âœ… GitHub workflows for Terraform plan and apply
- âœ… Staging environment infrastructure provisioned
- âœ… Production environment infrastructure provisioned

### 6. Kubernetes (K8s) Configuration

**Objective**: Define application deployment, configuration, and scaling with Kubernetes

**Actions**:
- Create Kubernetes manifests in `k8s/`:

k8s/ 
â”œâ”€â”€ base/ # Base configurations 
â”‚ â”œâ”€â”€ backend-deployment.yaml 
â”‚ â”œâ”€â”€ backend-service.yaml 
â”‚ â”œâ”€â”€ frontend-deployment.yaml 
â”‚ â”œâ”€â”€ frontend-service.yaml 
â”‚ â”œâ”€â”€ configmap.yaml 
â”‚ â”œâ”€â”€ secret.yaml # Reference only, actual secrets from Secret Manager 
â”‚ â”œâ”€â”€ ingress.yaml 
â”‚ â””â”€â”€ kustomization.yaml 
â””â”€â”€ overlays/ # Environment-specific overrides 
â”œâ”€â”€ staging/ 
â”‚ â”œâ”€â”€ kustomization.yaml 
â”‚ â”œâ”€â”€ replica-count.yaml 
â”‚ â””â”€â”€ ingress.yaml 
â””â”€â”€ production/ 
â”œâ”€â”€ kustomization.yaml 
â”œâ”€â”€ replica-count.yaml 
â”œâ”€â”€ hpa.yaml # Horizontal Pod Autoscaler 
â””â”€â”€ ingress.yaml

- **Use Kustomize** for environment-specific configurations
- Configure health probes:
  - **Liveness probe**: `/actuator/health/liveness` for backend
  - **Readiness probe**: `/actuator/health/readiness` for backend
  - Frontend: HTTP GET on root path
- Set resource requests and limits:
  - CPU: requests (guaranteed) and limits (max)
  - Memory: requests and limits
- Configure Horizontal Pod Autoscaler (HPA) for production
- Set up Ingress with managed SSL certificates
- Use External Secrets Operator to sync secrets from GCP Secret Manager
- Configure Network Policies for security

**Best Practices**:
- Always set resource limits to prevent resource starvation
- Use health probes to ensure K8s knows when pods are ready
- Use ConfigMaps for non-sensitive config, Secrets/External Secrets for sensitive data
- Label everything consistently for easier management
- Use namespaces to separate environments if sharing clusters

**Deliverables**:
- âœ… Kubernetes manifests in `k8s/base/` and `k8s/overlays/`
- âœ… Kustomize configurations for staging and production
- âœ… Health probes configured on all deployments
- âœ… Resource requests and limits defined
- âœ… HPA configured for production
- âœ… Ingress with SSL termination
- âœ… External Secrets Operator configured

### 7. Continuous Deployment (CD) Pipeline

**Objective**: Automated deployment to staging and production

**Actions**:
- Create `.github/workflows/cd-staging.yml`:
  - Trigger: Push to `develop` branch or manual workflow dispatch
  - Build and tag Docker images with commit SHA
  - Push images to GCR (Google Container Registry)
  - Deploy to staging GKE cluster using `kubectl` and Kustomize
  - Run smoke tests against staging
  - Notify team of deployment status (Slack, email)
- Create `.github/workflows/cd-production.yml`:
  - Trigger: Push to `main` branch, tags, or manual workflow dispatch
  - Require manual approval (GitHub Environments)
  - Build and tag Docker images
  - Push images to GCR
  - Deploy to production GKE cluster
  - Run smoke tests
  - Monitor rollout status
  - Notify team
- Configure GitHub Environments:
  - `staging`: Auto-deploy, no approvals needed
  - `production`: Require manual approval from designated reviewers
- Set up deployment strategies:
  - Rolling updates (default)
  - Consider blue-green or canary for critical services
- Implement rollback procedures:
  - `kubectl rollout undo deployment/<name>`
  - Or redeploy previous version via Git tag

**GitOps Alternative** (Optional):
- Use ArgoCD or Flux for GitOps-based deployments
- K8s cluster pulls changes from Git (vs. CI pushing to cluster)
- Better audit trail and declarative state management

**Deliverables**:
- âœ… `.github/workflows/cd-staging.yml` deploys to staging on `develop` branch
- âœ… `.github/workflows/cd-production.yml` deploys to production on `main` branch
- âœ… GitHub Environments configured with protection rules
- âœ… Automated smoke tests run post-deployment
- âœ… Rollback procedures documented and tested
- âœ… Deployment notifications set up

### 8. Observability and Monitoring

**Objective**: Gain visibility into application performance, errors, and infrastructure health

**Why Critical?** You can't fix what you can't see. Observability is essential for production systems.

**Actions**:
- **Logging**:
  - Structured logging (JSON format) in all services
  - Use appropriate log levels (DEBUG, INFO, WARN, ERROR)
  - Centralize logs: GCP Cloud Logging, ELK Stack, or Grafana Loki
  - Include correlation IDs for tracing requests across services
- **Metrics**:
  - Expose metrics via Spring Boot Actuator (`/actuator/metrics`)
  - Set up Prometheus to scrape metrics from K8s pods
  - Create Grafana dashboards for:
    - Application metrics (request rate, error rate, latency)
    - Infrastructure metrics (CPU, memory, disk, network)
    - Business metrics (user signups, transactions, etc.)
- **Tracing** (Optional, but recommended for microservices):
  - Implement distributed tracing with OpenTelemetry
  - Use Jaeger or Zipkin for trace visualization
  - Trace requests across frontend â†’ backend â†’ database
- **Alerting**:
  - Set up alerts for critical issues:
    - High error rates
    - Slow response times
    - Resource exhaustion (CPU, memory, disk)
    - Pod crashes or restarts
  - Configure alert channels (Slack, PagerDuty, email)
  - Define on-call rotation and escalation policies
- **Uptime Monitoring**:
  - External monitoring (Pingdom, UptimeRobot, or GCP Monitoring)
  - Monitor critical endpoints and user flows
  - Alert immediately on downtime

**Deliverables**:
- âœ… Structured logging implemented in all services
- âœ… Logs centralized and searchable
- âœ… Prometheus and Grafana deployed
- âœ… Dashboards created for application and infrastructure metrics
- âœ… Alerts configured for critical issues
- âœ… On-call rotation and escalation procedures defined
- âœ… Distributed tracing implemented (if applicable)

## Development Workflow Summary

**Daily Development Flow**:
1. Pull latest code from `develop`
2. Create feature branch: `git checkout -b feature/my-feature`
3. Develop locally using `docker-compose -f docker-compose.dev.yml up`
4. Write tests alongside code (TDD)
5. Run tests locally: `npm test` and `mvn test`
6. Commit and push: CI runs automatically
7. Create Pull Request when feature is complete
8. Address review comments and ensure CI passes
9. Merge to `develop` â†’ Auto-deploys to staging
10. Verify on staging, then merge `develop` â†’ `main` â†’ Deploys to production

**Branch Strategy**:
- `main`: Production-ready code, protected, deploys to production
- `develop`: Integration branch, protected, deploys to staging  
- `feature/*`: Feature branches, created from `develop`, merged back via PR
- `hotfix/*`: Emergency fixes, created from `main`, merged to both `main` and `develop`

**Release Process**:
1. Merge features to `develop` throughout the sprint
2. Test on staging environment
3. Create release PR: `develop` â†’ `main`
4. Run final QA and approval process
5. Merge to `main` â†’ Triggers production deployment
6. Tag release: `git tag v1.0.0` â†’ Push tag
7. Monitor production metrics and logs
8. Celebrate! ðŸŽ‰

## Key Takeaways

- **CI/CD from Day One**: Don't wait to set up automation
- **Test Early and Often**: Testing is not a separate phase, it's integrated
- **Infrastructure Before Applications**: Provision infrastructure before deploying apps
- **Security Throughout**: Secrets management, scanning, and least privilege from the start
- **Observability is Essential**: You must be able to see what's happening in production
- **Terragrunt for Multi-Environment**: Use Terragrunt to manage Terraform across environments
- **Automate Everything**: Manual processes are error-prone and don't scale

# Preferred Libraries and Packages

## Backend
- **Spring Data JPA**: For simplifying data access layers and database interactions.
- **Lombok**: To reduce boilerplate code (getters, setters, constructors) in Java classes.
- **Testcontainers**: For reliable integration tests with real services like PostgreSQL running in Docker.
- **Spring Boot Actuator**: For production-ready features like health checks and metrics.

## Frontend
- **Shadcn**: For building accessible and composable UI components. Built on top of Radix UI and Tailwind CSS.
- **Axios**: For making HTTP requests from the browser to the backend API.
- **Tailwind CSS**: For utility-first CSS styling.
- **React Testing Library**: For testing React components in a user-centric way.

## Shadcn UI Component Library

- **ALWAYS use `shadcn` (modern version)** - NOT the deprecated `shadcn-ui` package
- **Correct package**: `shadcn` is installed via `npx shadcn@latest init` and components are added with `npx shadcn@latest add <component>`
- **Import path**: Components should be imported from `@/components/ui/*` (e.g., `import { Button } from "@/components/ui/button"`)
- **NEVER install or reference `shadcn-ui`** - This is the old, deprecated package name
- Shadcn components are copied into your project (not installed as npm dependencies) and can be customized
- Built on Radix UI primitives with Tailwind CSS styling

# Spring Boot Best Practices

- **Dependency Management**: Always use the `spring-boot-starter-parent` POM to ensure dependency compatibility.
- **Configuration**: Use `application.properties` or `application.yml` for configuration. Use profiles (`application-dev.yml`, `application-prod.yml`) for environment-specific settings.
- **Testing**: 
  - Use `@SpringBootTest` for full integration tests.
  - Use `@DataJpaTest` for testing the persistence layer with an in-memory database like H2.
  - Use Testcontainers for integration tests that require external services like PostgreSQL to ensure production parity.

# Security Best Practices

## Environment Variables and Secrets
- **NEVER hardcode sensitive data** (passwords, API keys, tokens, secrets) in source code
- **ALWAYS use environment variables** for sensitive configuration
- **Backend (Spring Boot)**: Use `${VAR_NAME:default}` syntax in `application.properties`
  - Example: `spring.datasource.password=${DB_PASSWORD:postgres}`
- **Frontend (Next.js)**: Use `process.env.NEXT_PUBLIC_*` for client-side, `process.env.*` for server-side
- **Docker Compose**: Reference environment variables with `${VAR_NAME}` syntax
- **NEVER commit `.env` files** - only commit `.env.example` with placeholder values
- **Kubernetes**: Use Secrets or External Secrets Operator, never hardcode in YAML
- **Always validate** that `.env` is in `.gitignore`
- For local development, use `.env` files; for production, use secret management services (GCP Secret Manager, AWS Secrets Manager, etc.)

# React and Next.js Best Practices

## React Imports
- **NEVER use `import * as React from "react"`** - This causes build failures in Next.js Docker environments
- **NEVER use `React.` namespace references** (e.g., `React.FormEvent`, `React.ReactNode`) without importing React
- **ALWAYS use named imports**: `import { useState, useEffect, forwardRef } from "react"`
- **ALWAYS use type imports for React types**: `import type { ReactNode, FormEvent, HTMLAttributes } from "react"`
- Common type imports needed:
  - `FormEvent` for form submit handlers (instead of `React.FormEvent`)
  - `ReactNode` for children props (instead of `React.ReactNode`)
  - `ChangeEvent` for input change handlers (instead of `React.ChangeEvent`)
  - `MouseEvent` for click handlers (instead of `React.MouseEvent`)

## Client Components
- All components using React hooks or browser APIs must have `"use client"` directive at the top
- UI components that use `forwardRef`, `useState`, `useEffect`, etc. need `"use client"`

## React Hooks Dependencies
- Always include all dependencies in `useEffect`, `useCallback`, and `useMemo` dependency arrays
- Wrap functions used in `useEffect` with `useCallback` to prevent infinite loops
- Example:
  ```typescript
  const loadData = useCallback(async () => {
    // fetch logic
  }, [toast]); // Include all external dependencies
  
  useEffect(() => {
    loadData();
  }, [loadData]); // Include the callback function
  ```

## State Management and Optimistic Updates

### Avoid Race Conditions with Async State Updates
- **NEVER call `await loadData()` immediately after a mutation** - This creates race conditions where state can be undefined during re-renders
- **ALWAYS use optimistic updates** for mutations (create, update, delete operations)
- **Use functional state updates** `setState((current) => ...)` to ensure you're working with the latest state
- **Pattern to avoid**:
  ```typescript
  // âŒ BAD: Race condition - state can be inconsistent during reload
  await api.updateItem(id, data);
  await loadItems(); // Causes re-render with potentially undefined state
  ```

- **Pattern to use**:
  ```typescript
  // âœ… GOOD: Optimistic update with functional state
  const handleUpdate = async (id: string, data: UpdateData) => {
    // Optimistically update UI
    setItems((current) => 
      current.map((item) => item.id === id ? { ...item, ...data } : item)
    );
    
    try {
      await api.updateItem(id, data);
      toast.success('Updated successfully');
    } catch (error) {
      // Revert on error
      await loadItems();
      toast.error('Update failed');
    }
  };
  ```

## TypeScript with React
- Use type imports for React types: `type ReactNode`, `type HTMLAttributes`
- Prefer `forwardRef<HTMLElement, Props>` over `React.forwardRef`
- Use `ElementRef<typeof Component>` and `ComponentPropsWithoutRef<typeof Component>` for Radix UI components

## Next.js Specific
- Ensure `output: 'standalone'` is set in `next.config.js` for Docker deployments
- All client-side interactive components must be marked with `"use client"`
- Server components should NOT have `"use client"` directive

# Docker Best Practices Summary

## Production Builds
- **Use multi-stage builds** for compiled applications (Java/Spring Boot, Node.js)
- **Standardize on minimal runtime images**: `eclipse-temurin:17-jre` for Java, `node:20-alpine` for Node
- **DO NOT use Maven Wrapper** in Docker builds - use official `maven:3.9-eclipse-temurin-17` image
- Copy dependency files first for better layer caching (e.g., `pom.xml`, `package.json`, `package-lock.json`)

## Frontend Specific
- **ALWAYS copy `package-lock.json` explicitly** in Dockerfile: `COPY package-lock.json ./`
- **Use `npm ci --legacy-peer-deps`** instead of `npm install` for reproducible builds
- Never use conditional logic for package-lock.json - always ensure it exists
- Ensure `.dockerignore` does NOT exclude `package-lock.json`

## Development Workflow
- **Maintain separate configs** for dev and prod: `Dockerfile` vs `Dockerfile.dev`, `docker-compose.yml` vs `docker-compose.dev.yml`
- Use volume mounts in dev for hot-reload: `./src:/app/src`
- Enable file watching in Docker: `WATCHPACK_POLLING=true` for frontend, Spring DevTools for backend
- Use named volumes for dependencies to persist across restarts: `node_modules`, `.m2`

## Common Issues
- **Missing package-lock.json**: Always commit to version control
- **Peer dependency conflicts**: Use `--legacy-peer-deps` flag with npm ci
- **Cache invalidation**: Copy package files before source files to leverage Docker layer caching

# Best Practices Checklist

When creating a new project or service:
- [ ] Kubernetes manifests created in `k8s/` directory
- [ ] GitHub Actions workflows for CI in `.github/workflows/`
- [ ] Terraform configurations for infrastructure in `terraform/`
- [ ] External Secrets configured to pull from GCP Secret Manager
- [ ] Health probes and resource limits defined in K8s deployments
- [ ] Multi-stage Dockerfiles for optimized image builds
- [ ] Horizontal Pod Autoscalers configured for scalability
- [ ] Ingress with managed SSL certificates configured
- [ ] `.env.example` file with all required environment variables
- [ ] Documentation for deployment process in `DEPLOYMENT.md`